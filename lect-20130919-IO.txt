IO 

19/9/2013
 
 *
 * Данный коспект лучше всего сопровождать просмотром презентации
 * Здесь много непонятных мест, так что считайте это стартом для гуглежа ;)
 *

 - Java Input / Output
 - Input / Output Streams and Classes
 - Working with Files and Sockets

=== === === === === === === === === === === === === === === === === ===


В Джаве крутая библиотека ввода-вывода, изначально много заимствовано из C++.
Главноая особенность — кроссплатформенность, что для ввода-вывода сложнее, чем
для GUI. Проблемы начинаются с разных разделителей, заканчивая разным порядком
байт. При проектировании ввода-вывода пришлось пойти на уровень абстракции
«поток» (stream), не собвсем соответствующие потокам ввода-вывода ОС. Также классы
библиотек ввода-вывода получились очень специализированными. 

Стандартная библиотека ввода-вывода — java.io. Классы делятся на ввод и вывод,
символный и бинарный ввод/вывод и т.п.

Остались две проблемы

    Работа с интернациональными данными, кодировка

    Не все вещи, которые хочется делать, поддерживается java.io. 

        Во-первых это общение с нативными приложениями, так как у нее своя
        область памяти, а у нативных своя

        По умолчанию ввода-вывод блокирующийся. Во время чтения не может
        происходить запись, так как поток блокируется

Поэтому сделали еще одну библиотеку java.nio (New IO). Меньше классов, но
они более функциональные. Вряд ли рядловой программист будет с ними
связываться


=== === === === === === === === === === === === === === === === === ===

Поток (stream)

Это главная сущность. Не путать с thread.

Потоки можно рассматривать как своего рода «драйвер» для обращения к системным
устройствам. С одной стороны есть интерфейс (API), с другой — реализация
драйвера для конкретной ОС (и ее версии).

Кроме независимости от платформы можно менять API для разных типов драйверов.
В одном месте используется, например, файловый API, в другом — сетевой. При
этом переключение между потоками и типами ввода-вывода может происходить
динамически.

Например, System.out.println() можно перенаправлять в другие потоки (можно
перенаправить out, и тогда ввод-вывод будет уже связан не с консолью).


=== === === === === === === === === === === === === === === === === ===

Чтобы начать работать с каким-то устройством (файлом), надо построить цепочку
классов (они все узко специализированные, решают свои маленькие задачи).

Пример

    Вначале надо создать поток для подключения файла FileInputStream
        〉Далее подключаем поток для считывания данных из файла построчно FileReader
            〉Можно еще подключить поток, осуществляющий архивацию данных, например

То есть строится цепочка, и функциональность простого класса наполняется
функциональностью более сложного класса.


=== === === === === === === === === === === === === === === === === ===

New IO

Решает проблемы взаимодействия с нативными приложениями. Это требуется редко.
Например, для написания драйвера к БД.

Предоставлят неблокирующие потоки ввода-вывода, однако с ними надо быть очень
осторожными, так как запросто можно считать не те данные или записать данные
не туда, куда нужно. Легче получить ожидаемое с блокируюищми потоками.

Добавлено много кодировок. Однако проблема не была решена до конца, хотя это и
не проблема именно Java. Серверы приложений иногда зашивают намертво кодировки
где-то внутри себя, поэтому текст в производльной кодироке использовать не
получится. Чаще всего сиспользуется UTF-8.


=== === === === === === === === === === === === === === === === === ===

Потоки ввода и вывода

Сферические кони в вакууме

    InputStream     — поток для считавания информации приложением 
    OutputStream    — поток для выдачи информации приложением 

Сферический поток в вакууме умеет считывать информацию откуда угодно, но
только по одному байти поочередно. Причем, пока идет считывание, ничего
другого делаться не может.  Это своего рода «заикающийся» поток.

Решение — буферы. Они сами не считывают данные, но используют буферы для
считывания данных большими порциями. Считать один раз по 100 байт быстрее, чем
100 раз по одному байту. Кони с буферами:

    BufferedInputStream
    BufferedOutputStream

Если буфер не заполнится (допустим, на заданные 100 байт пришло только 90), то
буфер будет молча ожидать заполнения до конца, хотя его может и не случиться.
Это deadlock.

Для решения обязательно вызывается метод flush(), форсирующий отправление
буфера. Когда пишется собственный протокол для передачи данных по сети, после
команд отправки данных всегда нужно выполнять flush(), чтобы буфер не ждал молча
недостающих байт.


=== === === === === === === === === === === === === === === === === ===

Байтовые потоки 

Передают данные так, как они хранятся. В зависимости от ОС меняется порядок
записи. Однако, Java сама заботится о том, чтобы аписались данные в той
очередности, котрая используется в данной ОС.

Надо знать, в каком порядке передавать и полчать данные. Например, чтобы
знать, в какой последовательности считывать int (32 бита) и long (64 бита).
Если напутать очередность, то считается не то, что нужно.


=== === === === === === === === === === === === === === === === === ===

Символные потоки 

Фактически все равно используются байты. Но преобразование в строку
и наоборот производится самой Java.

Две проблемы

    Плохо годится для передачи числовых данных. Передавая "4", получим "4\0".
    Вместо строки длиной 1 получим строку длиной 3. Чтобы такого не произошло,
    в строки вводятся разделители, которые в обычных текстах не встречаются.

    Для передачи данных в нестандартных кодировках надо быть уверенным, что
    отправитель и получатель умеют с ними работать. Простой способ борьбы —
    убедиться в том, что есть доступ к кодровкам на обеих сторонах. Другое
    решение — юникод, хотя он и несколько жирнее других.


=== === === === === === === === === === === === === === === === === ===

Сферические кони

    java.io.InputStream
    java.io.OutputStream

Пользуются методом read() и write(), считывают по одному байту. Когда
ввод (вывод) заканчивается, они возвращают -1.

Если после использования буфера возвращается null, то считать не удалось.

    java.io.BufferedInputStream 

Для работы со строковыми данными 

    java.io.Reader – абстрактный класс для считывания текстовых данных
    java.io.Writer – абстрактный класс для записи текстовых данных

Reader работает на основе бинарного InputStream
Writer используется в JEE для генерации HTTP response в сервлетах


=== === === === === === === === === === === === === === === === === ===

Потоки заимствованы из Unix

System.out
    
    Позволяет писать текст в стандартный вывод это объект типа PrintStream. В
    файл переводить не надо, потому что это будет огромная помойка, т.к. туда
    пишут все, кому не лень

System.err

    Используется для вывода исключений это объект типа PrintStream по
    умолчанию направленный на консоль JVM может сохраняться в файл типа
    error.log

System.in

    Считывает данные со стандартного ввода это объект типа InputStream по
    умолчанию направлен на клавиатуру и получает из нее ввод, даже если этот
    поток не используется


Они объявлены как статические переменные класса System. Эти потоки можно
перенаправлять методами класса System 

    setIn()                 для ввода 
    setOut() и setErr()     для вывода

По умолчанию нельзя писать одновмеренно в консоль и файл, и что на выходе
попадет в одно место, не попадет в другое. Для таких вещей есть библиотеки
логирования.

Когда System.out.println() вызывается, поток блокируется, выполнение
останавливается, и при больших объемах вывода это становится критичным для
производительности. Обязательно нужно убирать эти вещи из продакшна.


=== === === === === === === === === === === === === === === === === ===

java.util.Properties

В JDK существует понятие системных свойств (properties) это кросс-
платформенный аналог переменных окружения 

Системные свойства 
    
    Встроенные 

        свойства самой JDK

    Пользовательские 
        
        различные конфигурационные параметры свойства задаются в формате
        propertyName=propertyValue, они могут быть переданы в систему
        через файлы .properties


При запуске 
    
    java -DpropertyName=propertyValue MainClass System.getProperties()

возвращает загруженные свойства. Они возвращаются в виде объекта
java.util.Properties

Properties хранит свойства как таблицу ключ=значение, методом getProperty()
возвращает значение по ключу. 

java.util.Properties содержит методы для работы с редактируемыми свойствами 

    load()      чтобы загружать свойства из файлов пользователя
    store()     чтобы сохранять свойства из файлов пользователя


Пример

    Properties props = System.getProperties();
    Enumeration propNames = props.propertyNames();
    while ( propNames.hasMoreElements() ) {
        String name = (String) propNames.nextElement();
        String value = props.getProperty(name);
        System.out.println("property " + propName + "=" + value);
    }


Результат работы примера

    java -DmyProp=theValue TestProperties
    property java.version=1.5.0-rc
    property java.compiler=NONE
    property java.specification.vendor=Sun Microsystems Inc
    ...
    property myProp=theValue


=== === === === === === === === === === === === === === === === === ===

java.util.Scanner

Используется для работы с потоками ввода текстовой информации.

Упрощает работу с потоками ввода, позволяя сразу считывать данные в нужном
формате и задавать разделитель между данными

Может работать как с потоками ввода (клавиатура, файл) так и готовыми
объектами типа String (см. StringTokenizer)

    Scanner s = new Scanner(System.in); 
    // по умолчанию разделителем служит " "
    String param = s.next();
    System.out.println("the param 1" + param);
    int value = s.nextInt();
    System.out.println("second param" + value);
    s.close();

Если Scanner подключается к строкам, то он фактически работает как
StringTokenizer. Если хочется превратить строку в число, то надо сделать
коверсию через readDouble(). Сканер сам пытается считать нужный размер (64
бита для double), он возвращает считанное число, если же у него не получилось
считать double, то он выбрасывает исключение. Удобно для проверки введенных
данных, в т.ч. рамках защиты от дурака (чтобы не открывать порт «abcd»,
например).


=== === === === === === === === === === === === === === === === === ===

Сериализация (Serialization)

Это перенос объекта из кучи куда-то вовне в виде байтового массива.

Просто выражаясь, это архивация объекта. Смысл сериализации в использовании в
сочетании с десериализацией — преобразованием байтового массива в «живой
объект» в рабочей ВМ. На этой просто идее постороена JEE, с помощью
сериализации информация передается по распределенным мощностям из ВМ в ВМ.

За сериализацию отвечает сама ВМ. Однако есть спец интерфейс
java.io.Serializable, который сигнализирует о том, что объект «не против того,
чтобы его сериализовали» для дальнейшей передачи куда-то. Не все объекты есть
смысл пересылать, например экземпляр Connection к БД, который может жить
только в ВМ, в которой он был создан. Или, например, если объект слишком
толстый. Сериализация охватывает все родительские объекты и все его связи с
другими объектами. Поэтому надо, чтобы программист знал четко, что делает, и
мог контролировать сериализацию.

Если надо передать объект с чрезмерно «жирным» полем, например, то это поле
можно пометить модификатором transient, и тогда оно передаваться не будет, и
вместо этого поля в другой ВМ будет значение по умолчанию, например null.

Важно иметь одинаковые версии классов (с одинаковыми полями и сигнатурами
методлов) для сериализации и десериализации.

Как обеспечить одну версию библиотек на всех серверах? За этим следит
Continuous Integration (CI).

Есть еще «экстернализация» — программист сам пишет способ преобразования
обекта с бинарный массив.


=== === === === === === === === === === === === === === === === === ===

Работа с файлами

В джаве с ними скучно. Есть java.io.File. В ней разделены операции для
манипулирования с файлами и для чтения и записи. Работа с файлом — это работа
с файловым дескриптором.

Каталоги и файлы предоставляются одним и тем же классом File. Сначала поэтому
надо выполнить проверку каким-то из методов
    
    isFile()
    isDirectory()

На эти объекты распространяются те же права доступа, что и в ФС, запущенная ВМ
наследует права запустившего ее пользователя. Для проверки прав доступа есть
методы

    canRead()
    canWrite() 

Объект File — это не файл в ФС. Новый файл не появится до явного вызова
создания файла или записи данных. На каталог распростаняются эти же правила.
Однако, если создавать файлы в несуществующем каталоге, то будет ошибка.

По умолчанию все файлы создаются в относительном пространстве, начиная (по
умолчанию) с user.dir. Чтобы поменять это, надо указывать полный путь к
файлам. Надо учитывать разделители в путях ФС на разных платформах. В
библеотеке Apache Commons есть удобные вещи для этого. 


Пример

    // Создаем два дескриптора, ошибок тут не будет, они бываеют на чтении
    // и записи
    File file1 = new File("input.txt");
    File file2 = new File("output.txt")
    try {

        // Готовим поток для построчного считывания файла.
        BufferedReader in = new BufferedReader(new FileReader(file1));

        // Готовим поток для построчной записи файла.
        PrintWriter out = new PrintWriter(new FileWriter(file2));
        String s;
        
        // Считываем файл построчно и записываем в другой файл
        s = in.readLine();
        
        while ( s !=  null ) {
            out.println(s);
            s = in.readLine();
        }
        
        // Обазательно закрываем оба потока, т.к. через них могут утекать ресурсы
        // как ВМ, так и native     
        in.close();     
        out.close();

    } catch (IOException ioex) {
        // обрабатываем исключения
    }

Чаще, правда, потоки закрываются в блоке finally.


=== === === === === === === === === === === === === === === === === ===

Сетевое взаимодествие

Сокет – это соединение между двумя компьютерами. В JSE для этого используется
базовый класс java.net.Socket.

Соденинение устанавливается между клиентским сокетом и серверным. Серверный
сокет обычно остается на месте, к нему подключаются клиентские (клиент как
правило подключается к серверу, а не наоборот).

Класс Socket позволяет подключаться к удалённым ресурсам, получать и
отправлять данные в дуплексном режиме.

При создании сокета конструктору необходимо указать порт и адрес подключения в
виде строки или объекта java.net.InetAddress.

Система сама выберет порт для сокета на локальной стороне. Метод
getLocalAddress() позволяет получить такую информацию.

Сокеты могут использоваться как для TCP, так и для UDP. Для этих целей
используется класс DatagramSocket.

Из сокета можно извлечь стандартные потоки ввода/вывода эти потоки
используются для отправки/получения информации. Закрытие потока не означает
закрытие сокета, но закрытие сокета автоматически закрывает и его потоки.

    Socket sock = new Socket(server, port);
    Writer out = new OutputStreamWriter(sock.getOutputStream());
    InputStream in = new BufferedInputStream(sock.getInputStream( ));

Идеально, когда сервер известен по IP, чтобы не тратить ресурсы на запрос к
DNS-серверу и не напороться на проблемы с политикой безопасности.


4 типа сокетов:

    tcp socket
    udp socket
    multitask socket
    server socket


=== === === === === === === === === === === === === === === === === ===

Модели сетевого взаимодествия

    Point-to-Point (P2P)
        
        Классическая связь клиент-серверной модели, они знают друг друга. Если
        один участник отвалится, то соединение прерывается

        Применяется в серверных сокетах

    Publish–Subscribe   https://en.wikipedia.org/wiki/Publish/subscribe
        
        Сообщения отправляются без ведома о том, будут ли они кем-либо прочитаны.
        Их читают «подписчики», если таковые есть. Шина работает и без
        подписчиков.

        Так работает мультикастинг


=== === === === === === === === === === === === === === === === === ===

Серверный сокет используется только для подключения клиентов, а не для
передачии информации. За прием «входящих звонков» отвечает класс
java.net.ServerSocket. Для создания серверного сокета достаточно указать
только порт.

При подключении клиента сервер открывает ему новый сокет общение между
клиентом и сервером идет по этому новому сокету.  То есть определенный порт
используется только для подключения, после которого соединение перебрасывается
на другой порт.

После отключения надо ждать «звонка» от следующего клиента. Серверный сокет
блокируется, пока кто-то еще не «позвонит». Если сервер не очень популярен, то
можно заблокироваться «намертво» в режиме ожидания, поэтому для серверных
сокетов указывается таймаут.

Обратная ситуация — слишком много клиентов. Севреный сокет может держать
клиентов на очереди, их количество указывается в параметрах. Другое дело, что
много клиентов нельзя держать, так как у них тоже есть таймаут, да и сервер
надо пожалеть, поэтому размер очереди входящих подключений обычно делается
7–13, к 14-му клиенту придет ConnectionException.

Обрабатывать подключение надо быстро и избавляться от него как можно быстрее.
Поэтому все серверные приложения являются многопоточными, они выпихивают
работу с клиентами в отдельные потоки. Задача за тем, чтобы сделать
подключение и выпихивание из очереди как можно более быстрым.

Как только кто-то подключился, делает переброс подключения в новый поток и
возврат к тому, чтобы встретиь нового клиента. То есть для этого по сути в
бесконечном цикле вращается минимальный встречающий код.

    ServerSocket server = new ServerSocket(2048);
    server.setSoTimeout(30000); // ограничить ожидание 30 сек
    while(1) {
        Socket s = server.accept( ); // обработать подключение
    }


Серверный сокет принимает подключения от других ресурсов

Особенности реализации серверных сокетов

    обработав подключение серверный сокет должен начать снова слушать порт
    серверные подключения лучше делать multi-threaded и endless

    закрытие серверного сокета не приводит к отключению клиентов

    в ожидании клиентов серверный сокет блокируется
    заблокированный сокет можно "разбудить" по тайм-ауту


=== === === === === === === === === === === === === === === === === ===

Multicast Socket

К одному серверу может подключаться много клиентов, роли между ними известны.

В мультикасте же участники равны, то есть это работает как некая шина для обмена
сообщений. Мультикаст реализауется на аппаратном уровне, сетевое железо должно
уметь его поддерживать. Сам по себе мультикастинг прост. Есть специальный
мультикастный сокет.

Для получения multicast нужна регистрация в группе. Регистрация осуществляется
по сетевому адресу группы. После входа в multicast группу программа может
отправлять или получать сообщения от других участников, а также покинуть
multicast группу и уже ничего не получать/отправлять.

Отправитель (publisher, то есть приложение-отправитель) может управлять сроком
действия сообщения

    MulticastSocket ms = new MulticastSocket(4000);
    InetAddress ia = InetAddress.getByName("224.2.2.2");
    ms.joinGroup(ia);
    byte[] buffer = new byte[8192];
    DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
    ms.receive(dp);
    ms.send(dp);
    ms.leave(ia);


=== === === === === === === === === === === === === === === === === ===

Перед соединением сервер должен уже работать, клиент не может «подождать»
сервер. Серверу достаточно знать порт, а клиенту надо знать IP и порт. После
подключения

      Сервер            Клиент
    OutputStream  →  InputStream
    InputStream   ←  OutputStream


Пример создания серверного сокета (без исключений)

    // создаём серверный сокет
    ServerSocket s = new ServerSocket(5432);

    // запускаем бесконечный цикл для обработки подключений
    while (true) {

        // ожидаем подключения клиента
        Socket s1 = s.accept();
        
        // получаем поток вывода для общения с клиентом
        OutputStream os = s1.getOutputStream();
        OutputStreamWriter osw = new OutputStreamWriter(osw);
        BufferedWriter bw = new BufferedWriter(osw);
        
        // отправляем сообщение
        bw.write("Hello World!");
        
        // закрываем подключение этого клиента и ждём следующего
        s1.close();
    }



Пример создания серверного сокета (без исключений)


    // подключаемся к указанному ресурсу
    Socket s1 = new Socket("127.0.0.1", 5432);
    
    // открываем поток для получения данных от сервера
    InputStream is = s1.getInputStream();
    DataInputStream dis = new DataInputStream(is);
    
    // считываем присланные данные
    System.out.println(dis.readUTF());
    
    // отключаемся от сервера
    s1.close();


Эти примеры не смогут работать друг с другом, потому что используются разные
типы потоков (BufferedWriter на сервере и DataInputStream на клиенте)


=== === === === === === === === === === === === === === === === === ===

Конец.