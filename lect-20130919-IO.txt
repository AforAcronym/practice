Потоки ввода-вывода блокируют исполнение потока выполнения, читать и писать
одновременно нельзя.


=== === === === === === === === === === === === === === === === === ===

java.util.Properties

В JDK существует понятие системных свойств (properties) это кросс-
платформенный аналог переменных окружения 

Cистемные свойства 
    
    Встроенные 

        свойства самой JDK

    Пользовательские 
        
        различные конфигурационные параметры свойства задаются в формате
        propertyName=propertyValue, они могут быть переданы в систему
        через файлы .properties


При запуске 
    
    java -DpropertyName=propertyValue MainClass System.getProperties()

возвращает загруженные свойства. Они возвращаются в виде объекта
java.util.Properties

Properties хранит свойства как таблицу ключ=значение, методом getProperty()
возвращает значение по ключу. 

java.util.Properties содержит методы для работы с редактируемыми свойствами 

    load()      чтобы загружать свойства из файлов пользователя
    store()     чтобы сохранять свойства из файлов пользователя


Пример

    Properties props = System.getProperties();
    Enumeration propNames = props.propertyNames();
    while ( propNames.hasMoreElements() ) {
        String name = (String) propNames.nextElement();
        String value = props.getProperty(name);
        System.out.println("property " + propName + "=" + value);
    }

Результат работы примера

    java -DmyProp=theValue TestProperties
    property java.version=1.5.0-rc
    property java.compiler=NONE
    property java.specification.vendor=Sun Microsystems Inc
    ...
    property myProp=theValue

                 
                 === === === === === === === === === === === === === === === === === ===

java.util.Scanner

Используется для работы с потоками ввода текстовой информации.

- упрощает работу с потоками ввода позволяя сразу считывать данные в нужном
формате и задавать разделитель между данными

- может работать как с потоками ввода (клавиатура, файл) так и готовыми
объектами типа String (см. StringTokenizer)

    Scanner s = new Scanner(System.in); 
    // по умолчанию разделителем служит " "
    String param = s.next();
    System.out.println("the param 1" + param);
    int value = s.nextInt();
    System.out.println("second param" + value);
    s.close();

Если Scanner подключается к строкам, то он фактически работает как
StringTokenizer. Если хочется превратить строку в число, то надо сделать
коверсию через readDouble(). Сканер сам пытается считать нужный размер (64
бита для double), он возвращает считанное число, если же у него проблема для
считывания double, то он выбрасывает исключение. Удобно для проверки введенных
данных, в т.ч. рамках защиты от дурака (чтобы не открывать порт «abcd»,
например).


=== === === === === === === === === === === === === === === === === ===

Сериализация (Serialization)

— перенос объекта из кучи куда-то вовне в виде байтового массива. Просто
выражаясь, это архивация объекта. Смысл сериализации в использовании в
сочетании с десериализацией — преобразованием байтового массива в «живой
объект» в рабочей ВМ. На этой просто идее постороена JEE, с помощью
сериализации информация передается по распределенным мощностям из ВМ в ВМ.

За сериализацию отвечает сама ВМ. Однако есть спец интерфейс
java.io.Serializable , который сигнализирует о том, что объект «не против
того, чтобы его пересылали по сети». Не все объекты объекты есть смысл
пересылать, например экземпляр Connection к БД, который может жить только в
ВМ, в которой он был создан. Или, например, если объект слишком толстый.
Сериализация охватывает все родительские объекты и все его связи с другими
объектами. Поэтому надо, чтобы программист знал четко, что делает, и мог
контролировать сериализацию.

Если все-таки надо передать «жирный» объект за счет «жирного» полем, то это
поле можно пометить модификатором transient, и тогда оно передаваться не будет
и вместо этого поля в другой ВМ будет значение по умолчанию, например null.

Важно иметь одинаковые версии классов (с одинаковыми полями и сигнатурами
методлов) для сериализации и десериализации.

Как обеспечить одну версию библиотек на всех серверах? За этим следит
Contineous Integration (CI).

Есть еще «экстернализация» — программист сам пишет способ преобразования
обекта с бинарный массив


=== === === === === === === === === === === === === === === === === ===

Работа с файлами

В джаве с ними скучно. Есть java.io.File. В ней разделены операции для
манипулирования с файлами и для чтения и записи. Работа с файлом — это работа
с файловым дескриптором.

Каталоги и файлы предоставляются одним и тем же классом File. Сначала поэтому
надло выполнить проверку isFile() и isDirectory(). На эти объекты
распространяются те же права доступа, что и в ФС, запущенная ВМ наследует
права запустившего ее пользователя. Для проверки прав длоступа есть методы

    canRead()
    canWrite() 

Объект File — это не файл в ФС. Новый файл не появится до явного вызова
создания файла или записи данных. На каталог распростаняются эти же правила.
Однако, если создавать файлы в несуществующем каталоге, то будет ошибка.

По умолчанию все файлы создаются в относительном пространстве, начиная (по
умолчанию) с user.dir. Чтобы поменять это, надо указывать полный путь к
файлам. Надо учитывать разделители в путях ФС на разных платформах. В
библеотеке Apache Commons есть удобные вещи для этого. 


Пример

    // Создаем два дескриптора, ошибок тут не будет, они бываеют на чтении
    // и записи
    File file1 = new File("input.txt");
    File file2 = new File("output.txt")
    try {

        // Готовим поток для построчного считывания файла.
        BufferedReader in = new BufferedReader(new FileReader(file1));

        // Готовим поток для построчной записи файла.
        PrintWriter out = new PrintWriter(new FileWriter(file2));
        String s;
        
        // Считываем файл построчно и записываем в другой файл
        s = in.readLine();
        
        while ( s !=  null ) {
            out.println(s);
            s = in.readLine();
        }
        
        // Обазательно закрываем оба потока, т.к. через них могут утекать ресурсы
        // как ВМ, так и native     
        in.close();     
        out.close();

    } catch (IOException ioex) {
        // обрабатываем исключения
    }

Чаще, правда, потоки закрываются в блоке finally.


=== === === === === === === === === === === === === === === === === ===

Сетевое взаимодествие

Сокет – это соединение между двумя компьютерами в JSE для этого используется
базовый класс java.net.Socket.

Соденинение устанавливается между клиентским сокетом и серверным. Серверный
сокет обычно остается на месте, к нему подключаются клиентские (клиент как
правило подключается к серверу, а не наоборот).

Класс Socket позволяет подключаться к удалённым ресурсам, получать и
отправлять данные в дуплексном режиме.

При создании сокета конструктору необходимо указать порт и адрес подключения в
виде строки или объекта java.net.InetAddress.

Система сама выберет порт для сокета на локальной стороне. Метод
getLocalAddress() позволяет получить такую информацию.

Сокеты могут использоваться как для TCP, так и для UDP. Для этих целей
используется класс DatagramSocket.

Из сокета можно извлечь стандартные потоки ввода/вывода эти потоки
используются для отправки/получения информации. Закрытие потока не означает
закрытие сокета, но закрытие сокета автоматически закрывает и его потоки.

    Socket sock = new Socket(server, port);
    Writer out = new OutputStreamWriter(sock.getOutputStream());
    InputStream in = new BufferedInputStream(sock.getInputStream( ));

Идеально, когда сервер известен по IP, чтобы не тратить ресурсы на запрос к
DNS-серверу и не напороться на проблемы с политикой безопасности.

4 типа сокетов:
    tcp socket
    udp socket
    multitask socket
    server socket


=== === === === === === === === === === === === === === === === === ===

Модели сетевого взаимодествия

    Point-to-Point (P2P)
        
        Классическая связь клиент-серверной модели, они знают друг друга. Если
        один участник отвалится, то соединение прерывается

        Применяется в серверных сокетах

    Publish–Subscribe   https://en.wikipedia.org/wiki/Publish/subscribe
        
        Сообщения отправляются без ведома о том, будут ли они кем-либо прочитаны.
        Их читают «подписчики», если таковые есть. Шина работает и без
        подписчиков.

        Так работает мультикастинг


=== === === === === === === === === === === === === === === === === ===

Серверный сокет используется только для подключения клиентов, а не для
передачии информации. За прием «входящих звонков» отвечает класс
java.net.ServerSocket. Для создания серверного сокета достаточно указать
только порт.

При подключении клиента сервер открывает ему новый сокет общение между
клиентом и сервером идет по этому новому сокету.  То есть определенный порт
используется только для подключения, после которого соединение перебрасывается
на другой порт.

После отключения надо ждать «звонка» от следующего клиента. Серверный сокет
блокируется, пока кто-то еще не «позвонит». Если сервер не очень популярен, то
можно заблокироваться «намертво» в режиме ожидания, поэтому для серверных
сокетов указывается таймаут.

Обратная ситуация — слишком много клиентов. Севреный сокет может держать
клиентов на очереди, их количество указывается в параметрах. Другое дело, что
много клиентов нельзя держать, так как у них тоже есть таймаут, да и сервер
надо пожалеть, поэтому размер очереди входящих подключений обычно делается
7–13, к 14-му клиенту придет ConnectionException.

Обрабатывать подключение надо быстро и избавляться от него как можно быстрее.
Поэтому все серверные приложения являются многопоточными, они выпихивают
работу с клиентами в отдельные потоки. Задача за тем, чтобы сделать
подключение и выпихивание из очереди как можно более быстрым.

Как только кто-то подключился, делает переброс подключения в новый поток и
возврат к тому, чтобы встретиь нового клиента. То есть для этого по сути в
бесконечном цикле вращается минимальный встречающий код.

    ServerSocket server = new ServerSocket(2048);
    server.setSoTimeout(30000); // ограничить ожидание 30 сек
    while(1) {
        Socket s = server.accept( ); // обработать подключение
    }


Серверный сокет принимает подключения от других ресурсов

Особенности реализации серверных сокетов

    обработав подключение серверный сокет должен начать снова слушать порт
    серверные подключения лучше делать multi-threaded и endless

    закрытие серверного сокета не приводит к отключению клиентов

    в ожидании клиентов серверный сокет блокируется
    заблокированный сокет можно "разбудить" по тайм-ауту


=== === === === === === === === === === === === === === === === === ===

Multicast Socket

К одному серверу может подключаться много клиентов, роли между ними известны.

В мультикасте же участники равны, то есть это работает как некая шина для обмена
сообщений. Мультикаст реализауется на аппаратном уровне, сетевое железо должно
уметь его поддерживать. Сам по себе мультикастинг прост. Есть специальный
мультикастный сокет.

Для получения multicast нужна регистрация в группе. Регистрация осуществляется
по сетевому адресу группы. После входа в multicast группу программа может
отправлять или получать сообщения от других участников, а также покинуть
multicast группу и уже ничего не получать/отправлять.

Отправитель (publisher, то есть приложение-отправитель) может управлять сроком
действия сообщения

    MulticastSocket ms = new MulticastSocket(4000);
    InetAddress ia = InetAddress.getByName("224.2.2.2");
    ms.joinGroup(ia);
    byte[] buffer = new byte[8192];
    DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
    ms.receive(dp);
    ms.send(dp);
    ms.leave(ia);


=== === === === === === === === === === === === === === === === === ===

Перед соединением сервер должен уже работать, клиент не может «подождать»
сервер. Серверу достаточно знать порт, а клиенту надо знать IP и порт. После
подключения

      Сервер            Клиент
    OutputStream  →  InputStream
    InputStream   ←  OutputStream


Пример создания серверного сокета (без исключений)

    // создаём серверный сокет
    ServerSocket s = new ServerSocket(5432);

    // запускаем бесконечный цикл для обработки подключений
    while (true) {

        // ожидаем подключения клиента
        Socket s1 = s.accept();
        
        // получаем поток вывода для общения с клиентом
        OutputStream os = s1.getOutputStream();
        OutputStreamWriter osw = new OutputStreamWriter(osw);
        BufferedWriter bw = new BufferedWriter(osw);
        
        // отправляем сообщение
        bw.write("Hello World!");
        
        // закрываем подключение этого клиента и ждём следующего
        s1.close();
    }



Пример создания серверного сокета (без исключений)

    // подключаемся к указанному ресурсу
    Socket s1 = new Socket("127.0.0.1", 5432);
    
    // открываем поток для получения данных от сервера
    InputStream is = s1.getInputStream();
    DataInputStream dis = new DataInputStream(is);
    
    // считываем присланные данные
    System.out.println(dis.readUTF());
    
    // отключаемся от сервера
    s1.close();


Эти примеры не смогут работать друг с другом, потому что используются разные
типы потоков (BufferedWriter на сервере и DataInputStream на клиенте)


=== === === === === === === === === === === === === === === === === ===

Конец.