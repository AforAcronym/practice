1/10/13

 - SQL and EDBMS
 - JavaDB Connectivity API
 - Object relational...


Работа в джаве заточена именно под реляционную модель, несмотря на то, что есть другие типы ДБ. Для ЕЕ-пргера работа делится на 3 части:
    - извлечение и храненние данных
    - преобразование каким-то образом
    - отображение перед клиентами (UI и тп.)

Главное в СУДБ (от прогера) — метаданные, т.е. структура, таблица, связи между таблицами, ключи и т.п. Данные могут быть представлены огромным количеством способов. Еще важный момент — транзакции. Их два типа: в самой Java-машине (контейнере) и в самом сервере БД. Они могут перекрываться или быть совершенно отдельными.


=== === === === === === === === === 

SQL 

Его надо знать обязательно, хотя бы читать и писать DML.

DML — Data Manipulation Language    — select, update, join...
DML — Data Definition Language      — для управления БД

Крайне нежелательно привязываться к конкретной реализации SQL (у него есть несколько версий стандартов).

Освновные операторы select, insert, update, delete, join (left-, right-).

Важный совет: всегда писать SQL-инструкции с перечислением столбцов и таблиц по именам. «SELECT *» — это плохо. 



=== === === === === === === === ===

JDBC 

Есть нескольок технологий для доступа к БД. Есть разные каркасы и т.п., все лежит на библиотеке JDBC. Она имеет драйверы для подключения к реляционным ДБ. «Снизу» лежит конкретная реализация подключения, а «сверху» — одно API. Какие-то нюансы могут тем не менее присутствовать. 

Оно лежит в java.sql и javax.sql


Типы драйверов: 

1. JDBC — ODBC bridge + ODBC-драйвер 
    Данные протаскивались по двум драйверам, низкая производительность

2. Половинчатые, написаны 50/50 на native API (C++) и Java
    Для каждой ОС свой собственный драйвер, проблемы с портируемостью.

(потом для БД стали использовать отдельные сервера)
3. 100% Java для использования через сеть
    Работает через сеть. Если БД и сервер приложений на одном хосте, то от прогонки данных по фиктивной сети получаются потери производительности

4. 100% Java
    Полностью написан на Java, это доступно далеко не для всех баз. У Oracle есть, а MSSQL нет, например. 

В 90% случаев используется 3-й тип.



=== === === === === === === === ===

Connectivity API 

Класс DriverManager — позволяет загрузить драйвер из CLASSPATH для нужной БД. По строке подключения происходит определения типа БД и выбирается драйвер. Этот подход работает для Java SE. Подключение делается вручную. 

В ЕЕ в сервере приложений регистрируются драйверы и подключения типа DataSource. То есть подключение осуществляется административным способом. В коде используется DataSource.

Важно правильно записать строку подключения и правильно передать параметры подключения. Они указываются лиюо в той жестроке подключения, либо в дополнительных свойствах объекта подключения. После подключения есть обхест Connection, и с ним дальше вся работа. 

У сокетов есть потоки ввода-вывода. Если закрыть Conncetion, то все связанные с ним состояния так же исчезнут.

SQL — декларативный язык, интерпретируется прямо в ДБ. Java просто передает SQL-инструкцию через JDBC в базу. Для этого есть java.sql.Statement. По существу это открытая сесссия с базой, туда можно построчно давать SQL, и он будет выполняться. Инструкция тупо передается и тупо выполняется. Для повторных запросов нет кэша, а в приложении часто запросы повторяются (например, добавление и удаление). Задача — как закэшировать инструкцию, чтобы ее не сосотавлять каждый раз заново. Для этого есть два интерфейса?

PreparedStatement /hardcode SQL/— готовим sql-строку, кэшируем на стороне базы, выполняем по необходимости. Что один раз в него записано, то и будет потом исполняться. 
CallableStatement /free SQL/— для вызова хранимых процедур, можно гонять любую инструкцию.

Параметры запросов можно указать для этих интерфейов. Они указываются с помощью знаков вопроса.
Перед каждым запуском можно определять параметры, которые подставятся вместо «?». 

                                    //1 2 3
    String sql = "SELECT ... FROM ... ? ? ?"
    PreparedStatement pstmt = con.prepareStatement(sql);
    pstmt.setInt(1, 500); // Для первого знака вопроса
    ResultSet rs = pstmt.executeQuery();

Надо помнить порядок и типы параметров. Например
    id = ?
        1
        setInt()

SQL-инъекция. В параметры запроса подпихивается SQL-код. Инструкция паразитная. Может просесть производительность или удалить что-то.



=== === === === === === === === === === === 

Проблема 1. В самом ResultSet данных нет, они по-прежнему в БД. Если он закроется или закроется его Connection, то данные станут недоступны.

Проблема 2. Данные находятся в динамическом состоянии. Поэтому как только ResultSet получен,его надо сразу обрабатывать, так как в БД может многое измениться. 

Извлечение по номеру работает быстрее

    while (rs.next()) {// Можно перемещаться только в одну сторону
        int id = rs.getInt("ID");
        String name = rs.getString(2);
        String department = rs.getInt("DEPARTMENT");
    }


    Connection 〉Statement 〉ResultSet
    |           |           |
    |           |           rs.close();     // Обязательно
    |           |
    |           st.close();         // Statement, стоит зарыть, он одноразовый
    |           pstmt.close();      // PreparedStatement многоразовый, закрывать его надо в последний момент
    |
    con.close()             // Пока работает приложение, con надо держать открытым


БД может за давностью времени сама закрыть соединение. Исправляется либо выставлением большим timeout (плохо), либо делается поток, который постоянно дергает БД какоим-то мелким фиктивным запросом. Это имеет смысл для самостоятельного приложения. Сервер приложений это делает сам.


Главный недостаток JDBC — заставляет программистов заботиться о низкоуровневых вещах в работе с БД. Если в таблице изменилась структура, надо переписывать код, работающий с JDBC.


=== === === === === === === === === === === 

Несмотря на то, что хранить неформализоавнне данные (файлы) в БД можно, это очень плохо. БД должна иметь ссылки на такие вещи, который должны лежать в ФС. Исключение — хранение сериализованого объекта. При этом надо обращать внимание на то, что, во-первых, БД не попытается применить с сериализованному объекту кодировку (надо хранить как BLOB, а не CLOB). Во-вторых, запись и чтение проходит как входной и выходной потоки. Если происходит некая ошибка, то данные перетекают не полностью, и оюъект восстановить не получится. В-третьих, выкачивающее приложение должно уметь восстанавливать сериализованный объект.


=== === === === === === === === === === === 

Data Access Object Design Pattern — спец шаблон (DAO), позволяющий разорвать приложение на две части — для работы с данными (DAO-часть) и для использования DAO-части для работы с данными.

Клиент, работая через интерфейс DAOFactory, не знает о его внутренностях и об устройсвте БД.

    CRUD-интерфейсы (Create Read Update Delete)
        .add()
        .remove()
        .get()
        ...

Вся логика работы с БД сконцентрирована в одному-двух классах, а не размазывается по други классом. 

Приложение разрабатывется быстрее. DAO-шаблон можно таскать в разные приложения и «натягивать» ан разные базы. Если в БД что-то поменяется, сломается только один класс.


=== === === === === === === === === === === 

Object Relational Mapping (ORM)
Шаблон Persistence Context

ORM-каркас избавляет от ряда проблем.

Есть классы Java и табица БД. Есть четкая привязка (таблица соответствия), которая указывает, какое поле класса соотвествует какому полю таблицы БД. Здесь на помощь приходит Persistence Context, он генерит JDBC DAO во время исполнения.

    + Очень просто разрабатывать приложение, надо лишь написать таблицу соответствия, после чего каркас ORM (Persistence Context) берет на себя всю работу.
    + Удобно сопровождать приложение — вносим изменение в привязку, даже в идеале не надо ничего перекомпилировать
    + Возможно реализовать сложных объектных схем (наследование, ссылки)

    - Снижение быстродействия
    - Собственные языки JPQL/HQL
    - Возможные ошибки в ORM-каркасах


=== === === === === === === === === === === 

ORM — скорее теория, чем практика. Практика — это JPA и Hibernate. Приложений, работающих на JPA в чистом виде, не существует. Hibernate может гораздо больше, чем просто реализацию JPA.

     Java  ←→  XML ←→  DB  

XML — файл конфигурации. Его можно менять, не трогая код. Генерируется либо из кода (приходит к базе), либо из базы (навызывается код). На практике никто этим не пользуется. 

Еще используются аннотации (проще и с потерей гибкости)

    @Java  ←→  DD

Обычно выбирают второй путь, потому что очень редко изменения в базе не приводят к изменениям в классах.


=== === === === === === === === === === === 

В JPA EntityManager, в Hibernate — Session — это Persistence Context. В Persistence Context отправляется запрос, откуда дальше поступает в БД, затем ответ из БД идет в него же, а из него возвращается ссылка. Если в этом объекте что-то меняется, то такое же изменение появляется в БД, то есть Persistence Context синхронизирует изменения (в обе стороны).

Объект можно вырвать из Persistence Context, нарушив синхронизацию. Он называется detached. И дальше делать с ним, что угодно. Можно положить этот объект обратно, Persistence Context сможет сделать это, потому как его объекты имеют свои идентификаторы. Свой объект в Persistence Context будет обновлен вновь пришедшим объектом, который перестанет быть detached. 

БД имеет приоритет над Persistence Context, если в первой что-то изменится, то изменения из Persistence Context приняты не будут. Допустим, есть два Persistence Context-а, тогда, в случае нескольких подключений к базе, могут возникать конфликты. Можно два Persistence Context-а соединить в один, если они оба принадлежат EE. 

Допустим, просим Persistence Context удалить объект. Запись в БД не затирается, а объект помечается как removed. Можно передумать, и тогда метка «removed» удаляется. С т.з. БД ничего не изменилось. Persistence Context умеет накапливать изменения, и затем разом накопленные изменения синхронизирует с базой (а в обратную сторону?) Persistence Context может обращаться к БД из-за каждой мелочи.

Синхронизация должна происходить по транзакциям. Вначале транзакции и в конце, когда фиксируются соотвествтенно начальное и конечное состояния. 


=== === === === === === === === === === === 

Транзакции

Под ними поднимается грппа операций, рассматриваемая как единое целое.

Атомарность. Транзацкий не может состоять из одного действия. Для пользователя выглядит как одно логическое дейсвтие, например перевод суммы денег с одного счета на другой. Технически же это невозможно. Как минимум две операции: вычитание суммы на одном счете и прибалвение на другом (на самом деле дейсвтий много). 

Согласованность. Если одно из действий не выполняется корректно, то транзакция в целом не выполняется, и происходит возврат БД в исходное состояние. Нельзя оказаться в промежуточной ситуации.

Изоляция. Одна транзакция не знает о существовании других, они не могут зависеть друг от друга. Они знают лишь об исходном состоянии.

Надежность. Четко зафиксированные транзакции, ничего не теряется.

Изолированные транзакции:
    
    T1 → A
    T2 → B

А затем, например, T1 захотела работать с B одновременно с A, а T2 с A одновременно с B. Тогда одна транзакция ждет, пока вторая не закончится. Кто первый встал — того и тапки. Это «плоская модель», используется в JSE/JEE.

Однако, может быть и deadlock, это вопрос качества захвата ресурсов и проектирования транзакций.

Дваподхода к управлению

    CMT - container managed transaction 
        устанавливаются границы транзакций , ее реализует контейнер

    BMT - bean managed transaction
        управление вручную через JTA, гибкость+сложность

Типы транзакций

    single
        с одним источником данных

    distributed
        могут охватывать несколько источников данных (не только БД, м.б. очереди сообщений, веб-ресурсы и т.п.)
        применяется протокол Two-Phase Commit (2PC). Выполняются действия на отдельных ресурсах (прекоммиты), если из обоих источников пришел успех, то происходит полноценный коммит.


=== === === === === === === === === === 

Уровни изоляции

    dirty read          — транзакции могут повлиять друг на друга
    read commit         — ожидается коммит одной для работы второй
    repeatable read     — невозможно считывать даже коммиты
    seriarizable        — полная блокировка данных во время транзакции, полная изоляция и падение производительности

Уровни указываются на уровнях
    
    методов / дляконкретныхтранзакций
    приложения / подключения
    БД

Если приложение в основномзанимается чтением, то можно ограничиться read commit или даже dirty read, если приложение постоянно вносит разные изменения, то seriarizable


=== === === === === === === === === === 

Транзакции CMT

Определеяются на уровне методов. Контейнер приложений начинает транзакцию (begin) на входе в метод и заканчивает ее (commit) на выходе из метода. Если внутри метода есть проблема, то производится откат (rollback).  Есть специальные аннотации, которые можно повесить на метод. 
    
    @Required       m1      — используется по умолчанию
    @RequiresNew    m2      — требует запуск
    @Mandatory      m3      — нет транзакции — делает rollback
    @NotSupported   m4      — приостановит транзакцию
    @Supports       m5      — влезает или проходит мимо, если нет транзакции
    @Never          m6      — если есть транзакция работает, то rollback

Любой метод в ЕЕ либо запускает новую транзацкию, либо встраивается в существующую.

    m1() → T1
   |
   |    〉m2() → T1 остановится, запустится T2
   |   |
   |   |    〉m3() → включается в T2
   |   |   |    
   |   |   |    〉 m4() → T2 приостанавливается
   |   |   |
   |   |    〉T2 восстанавливается
   |
   |    〉T2 заканчивается, продолжается T1
   |   
    〉 T1 завершается

Если транзакции вообще не нужны, то @Required только мешает.


=== === === === === === === === === === 

Rollback

В случае с BMT в конце едвелопер говорит либо commit, либо rollback. 

В случае с CMT контейнер сам решает. Коммит делается тогда, когдад все хорошо. Rollback делается только в случае исключений во время исполнения (runtime exception). Если вылетел checked exception, то коммит все равно произойдет, так как checked exception, то считается, что это предусмотренная бизнес-ситуация. Поэтому при необходимости, программист за checked должен бросить runtime exception. 


Есть транзакции, несколько методов. Надо не забывать проверку на rollback, чтобы не выполнять бесмыссленной работы.
    
    m1() → Checked Exception → Rollback
   |
   |    〉 m2() → надо проверить транзакцию на isRollbackOnly == true, и тогда делать ничего не надо
   |   |
   |   |   〉 m3() → надо проверить транзакцию на isRollbackOnly == true, и тогда делать ничего не надо
