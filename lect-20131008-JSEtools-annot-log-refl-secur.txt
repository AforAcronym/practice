Java SE Tools: Annotations, Logging, Reflections, Security

8/10/2013
 
 *
 * Данный коспект лучше всего сопровождать просмотром презентации
 * Здесь много непонятных мест, так что считайте это стартом для гуглежа ;)
 *

 - Annotations
 - Logging
 - Reflections
 - Security


=== === === === === === === === === === === === === === === === === ===

Аннотации 

Есть в современном виде с версии 1.5. Это один из видов метаданных. Метаданные
применяются везде в области ПО в XML, SQL, HTML, JSE

Аннотации — это модификаторы особого типа применяемые к пакетам, полям,
методам и переменным

Существуют стандартные типы аннотаций JSE, можно создавать собственный тип
аннотации c помощью мета-аннонатций

Применение аннотаций в JSE

    - документирование кода (JavaDoc работает на аннотациях)
    - дополнительная проверка на этапе компиляции
    - анализ кода (статический в IDE и динамический в runtime)
    - автоматическая генерация кода (JPA, JAXB)
    - управление исполняемым кодом (EJB 3.0, транзакции, например)


=== === === === === === === === === === === === === === === === === ===

С формальным появлением аннотаций подход к ним был модифицирован. Класс — это
сама аннотация. Аннотации — это Java-функции, лежащие в файлах *.java.

Существуют общие типы аннотаций (класс) – java.lang.Deprecated
Их использование в конкретном случае (объект) - @Deprecated

Формально аннотации можно «пристегивать» к любому выделенному узлу
спецификации Java: классы, методы, поля, локальным переменным внутри методов и
и.п. Однако чем шире поле действия аннотации, тем меньше от нее пользы. Они
хороши в рамках узкого применения. Самые полезные аннотации узкоприменимы.

Аннотации параметризуемы, т.е. могут адаптироваться для каждого конкретного
применения.

Все аннотации — константы, их значения устанавливаются на этапе компиляции, их
нельзя изменить в рантайме, поэтому в качестве параметров адаптации могут
использоваться константные не объектные типы

    - int, double и т.п.
    - объекты типа String, class, enum (это константы времени компиляции)
    - другие аннотации
    - массивы перечисленных типов


=== === === === === === === === === === === === === === === === === ===

В JSE присутствуют аннотации следующих типов

    - обобщённые встроенные аннотации (присутствуют в JSE)
    - специализированные аннотации различных библиотек
    - мета-аннотации для создания новых аннотаций

Мета-аннотации используются для создания аннотаций. С помощью мета-аннотаций
можно легко читать чужой код. 


=== === === === === === === === === === === === === === === === === ===

Над чем аннотация написана, к тому она и применяется

Пример использования - java.lang.Override

    public public class MyClass {
        @Override
        public boolean equals(MyClass object) { 
            return true; 
        }
    }


Пример использования - java.lang.SuppressWarning

    public static void main(String[] args) {
        @SuppressWarnings("unchecked")
        Collection<Integer> c = new LinkedList();
    } 


Пример использования нескольких - javax.persistence.*

    @Entity
    @Table(name = "BATCHHICN")
    public class BatchHicnEntity extends BaseEntity { }


=== === === === === === === === === === === === === === === === === ===

Создание аннотации

Объявляется в отдельном файле. Для создания аннотации используется конструкция
@interface cначала определяем аннотацию (можно с полями) в отдельном файле

    public @interface TODO { 
        String value( ) default "nothing"; 
    } 

Параметры указываются (на вид) как методы. Значение по умолчанию указывется
через слово default.

Используем её в исходном коде для методов, полей и т.д.

    @TODO("implement financial calculations") 
    public void calculateInterest(float amount, float rate) { } 

если в аннотации было объявлено несколько полей

    public @interface TODO { 
        String author();
        String comment(); 
    }

то они задаются в формате properties: name=value

@TODO(author="iorekhov", comment="implement calculations") 

Аннотации должны импортироваться в класс, как прочие используемые классы и
интерфейсы.

Значение по умолчанию нужно обязательно предусмотреть, если делать нужную
аннотацию либо с помощью default, либо в самом коде аннотации


=== === === === === === === === === === === === === === === === === ===

Мета-аннотации

Если аннотация не применима к тому, к чему она применена, то будет ошибка либо
на стадии компиляции, либо на стадии выполнения. В джавадоке аннотации есть
мета-аннотации, которые подскажут причины проблем. 

Мета-аннотации хранятся в пакете java.lang.annotation

Они применяются для аннотирования самих аннотаций. Типы:

    Target
        
        отвечает за область применения аннотации
        (класс, поле, метод, конструктор)

    Documented

        для включения аннотации в HTML, генерируемый JavaDoc

    Inherited

        позволяет наследовать аннотации из суперкласса

    Retention

        определяет область действия аннотации
        (исходный код, компилятор, виртуальная машина)


=== === === === === === === === === === === === === === === === === ===

java.lang.annotation.Target

Чем сильнее ограничена аннотация, тем более она полезна. С помощью Target
задается область действия аннотации — к чему ее можно применить.

Возможные значения Target находятся в enum ElementType. Эти значения включают
в себя

    TYPE                класс, интерфейс или enum, но не аннотация
    FIELD               поле класса
    METHOD              метод класса
    PARAMETER           параметр метода класса
    CONSTRUCTOR         конструктор
    LOCAL_VARIABLE      локальная переменная
    ANNOTATION_TYPE     аннотация
    PACKAGE             пакет

Можно задавать как несколько значений

    @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})

так и вообще не указывать Target для своей аннотации тогда вашу аннотацию
можно применять к любому элементу, но, значит, тем меньше в ней
функциональности


=== === === === === === === === === === === === === === === === === ===

java.lang.annotation.Retention

    Retention — удерживающая способность; хранение; членство
    http://www.multitran.ru/c/m.exe?s=retention
    http://www.multitran.ru/c/m.exe?a=3&&s=retention&sc=357&l1=1&l2=2

Retention управляет отношением JVM к вашим аннотациям. Она объявляется в
файле, у нее есть три пути (возможные реакции JVM заложены в enum
RetentionPolicy)

    SOURCE      считывается компилятором и в бинарный class-файл не попадает
    CLASS       попадает в class-файл, но игнорируется JVM
                толку от этого мало, используется анализаторами байт-кода
    RUNTIME     попадает в сlass-файл и загружается в JVM

Retention может принимать только одно значение из списка, по умолчанию
используется значение RetentionPolicy.CLASS


=== === === === === === === === === === === === === === === === === ===

java.lang.annotation.Inherited

Аннотации по умолчанию не наследуются. Если класс имел какую-то аннотацию, то
его потомки не будут иметь о ней ни малейшего понятия.

Чтобы не возникло такой проблемы с вашими аннотациями, надо сделать их
наследуемыми с помощью мета-аннотации Inherited, применив её при определении
вашей aннотации, тогда классы-наследники унаследует все аннотации родителя, а
аннотации переопределенных методов и полей наследоваться не будут.


=== === === === === === === === === === === === === === === === === ===

java.lang.annotation.Document

В процессе подготовки отправки продукта, разработчик обязан предоставить
документацию в виде JavaDoc. По умолчанию аннотации при генерации джавадока
игнорируются. Чтобы аннотация попала в документацию, нужно повесить на
аннотацию мета-аннотацию Documented.












=== === === === === === === === === === === === === === === === === ===

Логгирование

Логгирование часто недооценивается. 80% затрат разработчика — разработка, 80%
заработка — поддержка продукта.

Важно сделать поддерживаемый продукт, а не одноразовый. Чтобы это было не так
сложно и можно было заработать на поддержке без больших проблем, надо грамотно
отслеживать состояние приложения. В частности нужно правильно строить систему
логгирования для отслеживания ошибок, расследования инцидентов и т.д.

Простой вариант — System.out, но как минимум он влечет потерю
производительности из-за того, что он основан на блокирующемся вводе-выводе. К
тому же файлы логов переписываются, и выводом надо управлять.

Второй радикальный вариант — разработка своей системы журналирования. Но это
лишняя нагрузка на команду разработчиков. Деньги платят не за это.

Стандартами стали 

    - log4j от Apache 
    - java.util.logging от Oracle

=== === === === === === === === === === === === === === === === === ===


Модель логгирования

logger

    - объекты используемые для вывода информации 

        - сначала logger необходимо сконфигурировать (вне приложения)
        - затем получить к нему доступ в приложении 
        - потом можно выводить через него информацию

level 

    - определяют тип выводимой информации

        - позволяют разделить информацию по типам 
        - нужны для обеспечения требуемого уровня логгирования

appender

    - поток вывода, определяет куда выводить информацию (их может быть
    несколько, т.е. сразу можно выводить информацию в несколько мест одновременно)

        - позволяют направить информацию в файл или консоль
        - необходимы для logging в сложном приложении

layout

    - определяют в каком виде выводить информацию (время, место в коде и т.п.)

        - позволяет определить откуда и когда поступила информация 
        - необходимы для практического использования логов


Разные логгеры отличаются друг от друга по именам. Имена задаются в стандарте
java пакетов – "com.foo", но не имеют к реальным пакетам никакого отношения,
это просто де-факто устоявшийся стандарт.

За счет наименования строится иерархия логгеров. Логгер "com.foo.bar"
наследует свойства "com.foo". 

Доступ к логгеру в Java осуществляется по его имени. Принято, чтобы имя
логгера соответствовало классу или пакету или соответствовало логической
структуре - "DB", "WEB"

    privte static Logger log = Logger.getLogger("my.log");

Еще логгеры иногда называют в соответствии с областью применения (БД или еще
что-то). Такой логгер надо поместить в CLASSPATH.


=== === === === === === === === === === === === === === === === === ===

Уровни логгирования

Какую информацию необходимо выводить?

     - подробные сведения о работе метода
     - передача управления между объектами
     - информация о выполненных бизнес задачах
     - информация о произошедших ошибках

Для вывода информации существуют разные уровни логгирования. Чтобы
контролировать количество информации, выводимой в файл, для log4j
существуют следующие уровни
    
    DEBUG < INFO < WARN < ERROR < FATAL

В java.util.logging определены

    FINEST < FINER < FINE < CONFIG < INFO < WARNING < SEVERE

Для вывода сообщений требуемого уровня нужно использовать соответствующий
метод (предпочтительный)
    
    info("order completed") 
    error("ololo!")

или явно указывать уровень (это лучше, чтобы глаз не замыливался)

    log(ERROR, "can’t delete order")

Уровни расположены по ужесточению правил логгирования.

То, что выводится на уровне debug, игнорируется на error.

Есть у логгера уровень установлен в ERROR, то выводиться будет только ERROR и
FATAL. В продакшне обычно ставить ERROR, максимум WARNING. 


=== === === === === === === === === === === === === === === === === ===

Аппендеры

Объекты appender используются для вывода сообщений, соответствующих  уровню
логгирования данного логгера. Любой логгер может поддерживать несколько
аппендеров, осуществляя одновременно вывод и в консоль и в файл. Все аппендеры
многопоточны. Использование аппендеров не влияет на производительность, так
как работает в отдельном потоке, что может в свою очередь привести к
рассинхронизации

    - сообщение напечатано, а действие еще не выполнено
    - или наоборот

Но следует бояться скрытой нагрузки при логгировании

    logger.debug("result: " + myObject.doSomething());

Основную нагрузку даст вызов метода doSomething() даже если эта информация в
конечном итоге и не будет выводиться (например, выдается в WARNING, а задан
уровень ERROR, сообщения все равно генерируются). Нужно контролировать сбор
информации в зависимости от уровня логгирования.


В log4j определены несколько типов аппендеров

    ConsoleAppender         печать в консоль, помирает вместе с консолью
    FileAppender            печать в файл
    RollingFileAppender     вывод в файл с его пересозданием
    SocketAppender          вывод сообщений на сокет
    SMTPAppender            отправка сообщений по почте

Также можно создать собственный appender


=== === === === === === === === === === === === === === === === === ===

Объекты layout определяют формат содержимого лога, позволяя выводить
информацию в виде HTML или XML, однако чаще всего используется шаблонами (pattern
layout) и TXT-файлы

pattern layout работает аналогично методу printf(), выводя информацию
согласно заданному шаблону

Правила задания шаблона

    %с – название логгера
    %C – имя класса, где был вызван логгер
    %p – вывод уровня сообщения
    %t – имя потока где был вызван логгер
    %d – дата и время вызова логгера
    %m – сама информация (текст сообщения)

Пример шаблона
    
    %-5p -%с [%t]: %m

Пример сообщения

    DEBUG com.foo [main]: my message

Слишком сложный формат может влиять на производительность


=== === === === === === === === === === === === === === === === === ===

Кинфигурация логгера

Конфигурация log4j может выполняться

     - через файл log4j.properties или log4j.xml
     - в runtime во время работы приложения

Первый вариант более предпочителен для использования, но конфигурационный файл
нужно прописать в CLASSPATH. Текстовый конфиг проще, однако и ошибиться в нем
проще, XML сразу оповестит о проблеме.

Пример конфигурации логгера. Допустим, сделали логгер "my.writer". Есть
параметры, которые указываются префиксом и суффиксом.

    # Сначала настраиваем appender my.writer
    log4j.appender.my.writer = org.log4j.RollingFileAppender
    log4j.appender.my.writer.logFile = out.log
    log4j.appender.my.writer.layout = org.log4j.PatternLayout
    log4j.appender.my.writer.layout.ConversionPattern = %d %p %t %m

    # Настраиваем logger по умолчанию
    log4j.rootLogger = DEBUG, my.writer
    
    # Настраиваем свой logger my.log
    log4j.logger.my.log = INFO, my.writer

Разные параметры задаются до или после имени


=== === === === === === === === === === === === === === === === === ===

Лучшие практики

Хорошо
    
    - использовать правильный уровень логгирования
    - ограничивать размер файла лога
    - просматривать важнейшие события

Плохо

    — System.out и System.err
    — вывод приватной/конфиденциальной информации
    — вывод большого количества информации в продакшне
    — использовать один лог для нескольких приложений
    — выводить неинформативные сообщения












=== === === === === === === === === === === === === === === === === ===

Reflections

API для работы с информацией о классе

    — IDE знает о методах и полях классов, делает подсказки
    — сервера приложений образабывают HTTP-запросы
    — библеотеки генерируют код

Основной смысл.

Строгая типизация влечет к тому, что чтобы вызвать методы объекта, надо знать
тип объекта. Если не знать тип объекта, то и нет возможности использовать его.
Reflections помогает в этом случае.

Существуют специальные классы для работы с классами, методами и прочими узлами
спецификации Java, они хранятся в java.lang.reflect

Преимущество 

    Можно проверить, если есть метод у объекта, и при желании его использовать
    — гибкость работы с классами.

Проблемы

    — сложность в отладке и сопровождении
    — возможные потери производительности

    поэтому часто reflections ипользуется наполовину, чтобы брать информацию о
    классе

Пример

    Method method1 = ob1.getClass().getMethod("methodA", null);
    method1.invoke(ob1, null);


=== === === === === === === === === === === === === === === === === ===

Информация о классе

    — через объект
    — загрузчик классов

Через объект

    Class clazz = new MyClass1().getClass();

Системный загрузчик классов

    ClassLoader cl = ClassLoader.getSystemClassLoader();    
    Class clazz = cl.loadClass("mypackage1.MyClass1", true);
    // Надо следить за CLASSPATH

Проблема начинается, когда есть несколько загрузчиков классов. Это может
привести к разным приколам, даже если один и тот же класс загружен разными
загрузчиками




=== === === === === === === === === === === === === === === === === ===

Безопасность

Системная безопасность 

    SystemManager, Permissions, все действия отслеживаются SystemManager.

Безопасность приложения — способ защиты приложения от пользователя/кракера

    Криптография, аутентификация

JAAS — Java Authentification and Authorization System

Один из козырей Java — проектировалась изначально с требованиями к
безопасности. Для каждого типа кода свой уровень доступа

    — нельзя загрузить байткод, который был изменен. 
      на уровне приложения авторизация и аутентификация пользователей для
    — проведения операций, криптография
    — обмен между приложениями


=== === === === === === === === === === === === === === === === === ===

Основа безопасности платформы Java — «песочница», в которой работает
приложение и которая контролируется JVM, она следит за каждым действием.
На её основе разработана архитектура безопасности Java

    1. существует политика безопасности
    2. на её основе определяется уровни доступа для запущенного кода
       код разделен на функциональные области (домены — GUI, сеть и т.п.)
    3. уровни доступа определяются свойствами кода (автор, подпись)
    4. при выполнении действия выполняется проверка уровня доступа

Им соответствуют следующие компоненты

    1. security policy
    2. access permissions
    3. protection domains
    4. access control checking
    5. privileged operations

Некоторые базовые возможности вынесены за рамки Java, например, авторизация,
аутентификация, шифрование. 

Авторизация и аутентификация — частая задача в разработкею. Аутентификация
работает на основе ролей. Если есть пользователь принадлежит такой-то роли, то
ему разрешены такие-то действия. Не нужно реализовывать системы управления
пользователями (Access Control), так как это сложно, да и есть уже готовые
библиотеки.

Аутентификация может быть как по паролю, так и по сетчатке глаза.

Из-за законодательства США в Java поставляется слабое (128-бит) шифрование.
Для более сильного шифрования надло использовать сторонние библиотеки.


=== === === === === === === === === === === === === === === === === ===

security policy конфигурируется снаружи, во время исполнения она
представляется объектами Policy

Policy использует объекты типа Permission для

    1. для конструирования списка допустимых действий для кода
    2. проверки допустимости выполнения запрошенной операции

Permission определены для практически любой операции

Можно создать свой тип, или взять системный AllPermission, используется по
умолчанию

Исполняемый код идентифицируется объектом CodeSource. Этот объект не виден
пользователю, но виден ВМ, и она видит, откуда код загружен. Этот класс
описывает URL и сертификаты исполняемого кода после этого конструируется
объект ProtectionDomain

    — содержит список разрешенных операций — объект Permissions
    — содержит идентифицирующий код — объект CodeSource


Пример определения политики безопасности в файле java.policy

    grant codeBase "file:${{dir}}/*" {permission AllPermission;};


=== === === === === === === === === === === === === === === === === ===

Класс SecurityManager – «мотор» архиектуры безопасности Java, он
используется, чтобы проверить доступ приложения к ресурсам для выполнения
операции нужно иметь разрешение на неё. SecurityManager постоянно спрашивается
на разрешение, для этого в SecurityManager есть метод checkPermission()

Приложение может получить или создать SecurityMananager, если у него есть для
этого нужный тип permission’a. 

Но есть и более важный secure класс – AccessController. Это final класс,
непосредственно выполняющий проверку. Он имеет всю информацию о контексте
(context) выполняющегося кода, стеке исполняющихся методов и protection
domain’ов потоков. Операция либо просто выполняется, либо вылетает
SecurityException

    SecurityManager sm = System.getSecurityManager();
    getPDperm = new RuntimePermission("getProtectionDomain");
    sm.checkPermission(getPDperm);


